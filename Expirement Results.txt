Over the course of a week, I set out to develop a simple application. The goal was to create an app that allows users to practice Helldivers 2 inputs, customize keybindings, and modify the UI in some way. By the end of the week, I had successfully built a working application for both Linux and Windows, even incorporating sound as an extra feature. However, I was unable to implement controller support. Despite this shortcoming, I was satisfied with the results.
After seeing yet another "AI will take our jobs" post online, I wondered: Could AI create the same program? And if so, would it be better?
To test this, I turned to ChatGPT, one of the more well-known AI models. I documented each prompt and output in a versioned file to track the progress. My initial prompt was: "In Java, write an app that lets you practice typing stratagems." The AI generated an application that provided phrases and measured typing accuracy. While this was somewhat related to my request, it wasn't exactly what I wanted. More notably, the AI didn't ask any clarifying questions—something a human developer likely would have done. For example, a person might ask, "What is a stratagem?" but the AI simply assumed an interpretation and as a consequence, the AI does not make you think about your request like a person would.
Since the initial version was only a terminal-based application, I asked ChatGPT to generate a Swing-based GUI. The tweak worked, but the functionality remained the same—it was still a simple typing app. At this point, I had to leave the chat to create an account, which disrupted the workflow. However, I restarted the process and continued testing.
Next, I asked the AI to create an array called STRATAGEMS, using the stratagem codes from the Helldivers wiki. I even provided a direct link to the wiki. Unfortunately, this did not work as expected. The AI changed generic phrases to names like "Supply Drop" and "Tank Destroyer." However, there is no "Supply Drop" in Helldivers—only "Resupply," which is different—and "Tank Destroyer" simply does not exist. It was clear that the AI misunderstood the source material.
To address this, I refined my prompt: "For the STRATAGEMS array, use the stratagem codes from the fourth column of Helldivers wiki, which will contain characters like '\u21E7'." Having already completed the project manually, I knew that the AI would need the correct keycodes for arrow inputs. I provided Unicode characters to make the request clearer. The AI successfully retrieved the stratagems and displayed the arrow keys in the prompt, but it didn't account for user inputs needing to match them. This is an obvious requirement to a human developer but not to the AI. Additionally, while previous versions of the AI-generated app included a timer, this version removed the visible timer display—despite still tracking input time in the background.
Another issue arose when I asked the AI to include all the stratagems from the wiki. The application only had 5 of the nearly 80 listed in the wiki. So I simply told the AI to do so for every stratagem in the wiki, and got the worst result by far from the prompt. Instead of just simply expanding the list, it also produced broken code:
public static void main(String[] args ::contentReference[oaicite:0]{index=0}
This wasn’t just any compile error—its failing to run main which is in every working java program ever . The AI had omitted a closing parenthesis from the main method, an essential part of syntax in programming any language. If someone unfamiliar with coding encountered this issue, they might struggle to diagnose and fix it.
I continued experimenting to see if the AI would correct its own mistakes, without being prompted. I asked it to add a keyboard listener that replaced standard keyboard inputs with direction symbols. The AI successfully implemented the listener, but in doing so, it removed the stratagems it had added in the previous step. On the plus side, it did correct the previous compile error, though it introduced new syntax variations compared to earlier iterations.
After five iterations, I had a basic working app—though it was still missing many stratagems. Adding the missing data would be a straightforward task for someone with minimal coding experience. Rather than continuing to battle an AI that kept erasing its own progress, I moved on to the next feature: a settings menu.
To my surprise, the AI-generated menu worked and even implemented menuItems, a more polished approach to menu creation, than what I originally used. I also asked it to remove the submit button and allow pressing Enter instead, which it executed successfully. Encouraged by this success, I asked it to modify keybindings and add options for changing colors and text size.
The UI design for changing keybindings was clunky—requiring four separate dialog boxes—but functional. The AI stored settings in a HashMap, meaning that every time the app restarted, users would have to reconfigure their keybindings. An experienced developer would recognize this flaw immediately. To address this, I prompted the AI to save settings so they persisted between sessions.
The AI attempted to implement this but introduced another serious issue: it included an action listener without defining the method it referenced, causing a compile error. This marked the third time that previously working code had inexplicably vanished. To see if it would recover, I asked it to add a JLabel displaying input time and to introduce a text size setting. The label appeared correctly, but more code had inexplicably disappeared—specifically, the loadSettings method and action listeners for keybindings and color changes. Additionally, the drop-down menu worked, but the app could no longer generate stratagem text, making it impossible to enter correct inputs.
I won’t detail all 20 iterations, but the pattern remained the same: each new prompt fixed previous errors while introducing new ones. This cycle of repairing lost code and adding minor features became increasingly frustrating.
Despite these challenges, the AI provided a few valuable insights. It introduced me to JColorChooser, a utility I hadn’t known existed and will likely use in future projects. It also demonstrated how to use properties files, a simpler alternative to the CSV-based approach I had initially implemented. Learning these concepts was a tangible benefit of using AI.
However, AI’s limitations were evident. It only understands input in a limited capacity and does not anticipate needs the way a human developer would. The non-deterministic nature of ChatGPT means it might randomly modify or remove code that should remain unchanged, sometimes leading to compile errors. While AI could be useful for generating small, isolated functions, it requires highly detailed instructions and constant oversight.
Based on this experiment, I—a hobbyist developer with less than a year of experience—was able to produce slightly better code than ChatGPT. Although I spent a week on my version (with some days off and plenty of distractions), this approach allowed me to truly learn how and why to code certain features. AI-assisted coding, on the other hand, often feels like patching leaks in a sinking ship without understanding why the leaks exist in the first place. You don’t understand why it is using parts over other or even if other parts event exist.

